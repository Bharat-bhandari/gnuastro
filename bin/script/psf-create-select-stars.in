#!/bin/sh

# Build a catalogue, with column names "columns", of reference stars from
# an astquery "dataset", with a $magnitud value between "min" and "max"
# which satisfies a "criteria" specified as awk code. Additionaly, if a
# segmented file is provided, only stars corresponding to clumps with
# AXIS_RATIO > "minaxisrario" are selected. All the accepted stars
# shouldn't have brilliant stars within a circle of radius
# "mindistaarcsec".
#
# Run with '--help' for more information.
#
# Original author:
#     Sepideh Eskandarlou <sepideh.eskandarlou@gmail.com>
# Contributing author:
#     Raul Infante-Sainz <infantesainz@gmail.com>
#     Mohammad Akhlaghi <mohammad@akhlaghi.org>
#     Carlos Morales-Socorro <cmorsoc@gmail.com>
# Copyright (C) 2020-2021, Free Software Foundation, Inc.
#
# Gnuastro is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# Gnuastro is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along
# with Gnuastro. If not, see <http://www.gnu.org/licenses/>.


# Exit the script in the case of failure
set -e





# Default parameter's values
hdu=1
min=19
max=20
show=""
quiet=""
output=""
tmpdir=""
catalog=""
segmented=""
keeptmp=""
minaxisratio=0.9
version=@VERSION@
mindistdeg=0.015277778
field="phot_g_mean_mag"
scriptname=@SCRIPT_NAME@
matchaperturedeg=3.0/3600
dataset="gaia --dataset=edr3"





# Output of '--usage'
print_usage() {
     cat <<EOF
$scriptname: run with '--help' to list the options.
EOF
}





# Output of '--help'
print_help() {
   cat <<EOF
Usage: $scriptname [OPTIONS] image.fits

This script builds a catalogue, with column names "columns", of reference
stars from an astquery "dataset", with a "field" magnitude value between "min"
and "max" specified as a chunk of awk code.
Additionaly, if a segmented file is provided, only stars which match clumps
within a given "matchaperturedeg", in pixels, and with an AXIS_RATIO >
"minaxisrario" are selected.

$scriptname options:
 Input:
  -h, --hdu=STR/INT       Extension name or number of input data.
  -S, --segmented=STR     Segmentation file obtained by Segment (astsegment).
  -d, --dataset=STR       astquery format dataset ("gaia --dataset=edr3", etc.).
  -f, --field=STR         Catalogue key field to identify the magnitude field
                          ("phot_rp_mean_mag", etc.).
  -m, --min=FLT           Minimum value of field.
  -M, --max=FLT           Maximum value of field.
  -a, --matchaperturedeg=FLT Aperture, in pixels, to match catalogue ra and
                          dec coordinates with clumps' ra and dec.
  -Q, --minaxisratio=FLT  Minimum axis ratio of a clump to be accepted.
                          Default to 0.9.
  -D, --mindistdeg=FLT    Minimum distance to more brilliant neighbour stars
                          to be accepted, in degree.
  -c, --catalog=STR       Catalog of stras contain of ra, desc, magnitude,
                          parrallax and parrallax_error.

 Output:
  -k, --keeptmp         Keep the build directory.
  -t, --tmpdir            Build directory (for intermediate files).
  -o, --output            Catalogue file.

 Operating mode:
  -h, --help              Print this help.
      --cite              BibTeX citation for this program.
  -q, --quiet             Don't print any commnent.
  -V, --version           Print program version.
  -s, --show              Show all the selected stars on top of the image using
                          ds9.

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponfing short options.

GNU Astronomy Utilities home page: http://www.gnu.org/software/gnuastro/

Report bugs to bug-gnuastro@gnu.org
EOF
}





# Output of '--version':
print_version() {
     cat <<EOF
$scriptname (GNU Astronomy Utilities) $version Copyright (C) 2020-2021, Free
Software Foundation, Inc. License GPLv3+: GNU General public license version 3
or later. This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written/developed by Sepideh Eskandarlou.
EOF
}





# Functions to check option values and complain if necessary.
on_off_option_error() {
   if [ "x$2" = x ]; then
       echo "$scriptname: '$1' doesn't take any values."
   else
       echo "$scriptname: '$1' (or '$2') doesn't take any values."
   fi
   exit 1
}

check_v() {
    if [ x"$2" = x ]; then
        echo "$scriptname: option '$1' requires an argument."
        echo "Try '$scriptname --help' for more information."
        exit 1;
   fi
}





# Separate command-line arguments from options and put the option values
# into the respective variables.
#
# OPTIONS WITH A VALUE:
#
#   Each option has three lines because we take into account the three common
#   formats:
#   For long option names, '--longname value' and '--longname=value'.
#   For short option names, '-l value', '-l=value' and '-lvalue'
#   (where '-l' is the short version of the hypothetical '--longname option').
#
#   The first case (with a space between the name and value) is two
#   command-line arguments. So, we'll need to shift it twice. The
#   latter two cases are a single command-line argument, so we just need to
#   "shift" the counter by one.
#
#   IMPORTANT NOTE: the ORDER OF THE LATTER TWO cases matters: '-h*' should be
#   checked only when we are sure that its not '-h=*').
#
# OPTIONS WITH NO VALUE (ON-OFF OPTIONS)
#
#   For these, we just want the forms of '--longname' or '-l'. Nothing
#   else. So if an equal sign is given we should definitely crash and also,
#   if a value is appended to the short format it should crash. So in the
#   second test for these ('-l*') will account for both the case where we
#   have an equal sign and where we don't.


while [ $# -gt 0 ]
do
   case "$1" in
   # Input parameters.
       -S|--segmented)         segmented="$2";                               check_v "$1" "$segmented";  shift;shift;;
       -S=*|--segmented=*)     segmented="${1#*=}";                          check_v "$1" "$segmented";  shift;;
       -S*)                    segmented=$(echo "$1" | sed -e's/-S//');      check_v "$1" "$segmented";  shift;;
       -h|--hdu)               hdu="$2";                                     check_v "$1" "$hdu";  shift;shift;;
       -h=*|--hdu=*)           hdu="${1#*=}";                                check_v "$1" "$hdu";  shift;;
       -h*)                    hdu=$(echo "$1" | sed -e's/-h//');            check_v "$1" "$hdu";  shift;;
       -e|--extscript)         extscript="$2";                               check_v "$1" "$extscript";  shift;shift;;
       -e=*|--extscript=*)     extscript="${1#*=}";                          check_v "$1" "$extscript";  shift;;
       -e*)                    extscript=$(echo "$1" | sed -e's/-e//');      check_v "$1" "$extscript";  shift;;
       -d|--dataset)           dataset="$2";                                 check_v "$1" "$dataset";  shift;shift;;
       -d=*|--dataset=*)       dataset="${1#*=}";                            check_v "$1" "$dataset";  shift;;
       -d*)                    dataset=$(echo "$1" | sed -e's/-d//');        check_v "$1" "$dataset";  shift;;
       -c|--catalog)           catalog="$2";                                 check_v "$1" "$catalog";  shift;shift;;
       -c=*|--catalog=*)       catalog="${1#*=}";                            check_v "$1" "$catalog";  shift;;
       -c*)                    catalog=$(echo "$1" | sed -e's/-c//');        check_v "$1" "$catalog";  shift;;
       -f|--field)             field="$2";                                   check_v "$1" "$field";  shift;shift;;
       -f=*|--field=*)         field="${1#*=}";                              check_v "$1" "$field";  shift;;
       -f*)                    field=$(echo "$1" | sed -e's/-f//');          check_v "$1" "$field";  shift;;
       -m|--min)               min="$2";                                     check_v "$1" "$min";  shift;shift;;
       -m=*|--min=*)           min="${1#*=}";                                check_v "$1" "$min";  shift;;
       -m*)                    min=$(echo "$1" | sed -e's/-m//');            check_v "$1" "$min";  shift;;
       -M|--max)               max="$2";                                     check_v "$1" "$max";  shift;shift;;
       -M=*|--max=*)           max="${1#*=}";                                check_v "$1" "$max";  shift;;
       -M*)                    max=$(echo "$1" | sed -e's/-M//');            check_v "$1" "$max";  shift;;
       -a|--matchaperturedeg)  matchaperturedeg="$2";                        check_v "$1" "$matchaperturedeg";shift;shift;;
       -a=*|--matchaperturedeg=*) matchaperturedeg="${1#*=}";                check_v "$1" "$matchaperturedeg";  shift;;
       -a*)                    matchaperturedeg=$(echo "$1" | sed -e's/-a//');  check_v "$1" "$matchaperturedeg";  shift;;
       -Q|--minaxisratio)      minaxisratio="$2";                            check_v "$1" "$minaxisratio";  shift;shift;;
       -Q=*|--minaxisratio=*)  minaxisratio="${1#*=}";                       check_v "$1" "$minaxisratio";  shift;;
       -Q*)                    minaxisratio=$(echo "$1" | sed -e's/-Q//');   check_v "$1" "$minaxisratio";  shift;;
       -D|--mindistdeg)        mindistdeg="$2";                              check_v "$1" "$mindistdeg";  shift;shift;;
       -D=*|--mindistdeg=*)    mindistdeg="${1#*=}";                         check_v "$1" "$mindistdeg";  shift;;
       -D*)                    mindistdeg=$(echo "$1" | sed -e's/-D//');     check_v "$1" "$mindistdeg";  shift;;

# Output parameters
       -k|--keeptmp)         keeptmp=1; shift;;
       -k*|--keeptmp=*)      on_off_option_error --keeptmp -k;;
       -t|--tmpdir)            tmpdir="$2";                                    check_v "$1" "$tmpdir";  shift;shift;;
       -t=*|--tmpdir=*)        tmpdir="${1#*=}";                               check_v "$1" "$tmpdir";  shift;;
       -t*)                    tmpdir=$(echo "$1" | sed -e's/-t//');           check_v "$1" "$tmpdir";  shift;;
       -o|--output)            output="$2";                                  check_v "$1" "$output"; shift;shift;;
       -o=*|--output=*)        output="${1#*=}";                             check_v "$1" "$output"; shift;;
       -o*)                    output=$(echo "$1" | sed -e's/-o//');         check_v "$1" "$output"; shift;;

   # Non-operating options.
       -q|--quiet)             quiet=" -q"; shift;;
       -q*|--quiet=*)          on_off_option_error --quiet -q;;
       -?|--help)              print_help; exit 0;;
       -'?'*|--help=*)         on_off_option_error --help -?;;
       -V|--version)           print_version; exit 0;;
       -V*|--version=*)        on_off_option_error --version -V;;
       --cite)                 astfits --cite; exit 0;;
       --cite=*)               on_off_option_error --cite;;
       -s|--show)              show=1; shift;;

   # Unrecognized option:
       -*) echo "$scriptname: unknown option '$1'"; exit 1;;

       # Not an option (not starting with a `-'): assumed to be input FITS
       # file name.
       *) inputs="$1 $input"; shift;;
   esac
done





# Basic sanity checks
# ===================
#
# If the input image has not been given at all.
if [ x"$inputs" = x ]; then
    echo " $scriptname: no input image file specified."
    echo "Run with '--help' for more information on how to run."
	exit 1
fi

# Check that if 'matchaperturedeg' is not specified as input,
# Set its value to'3.0/3600'
arcsec_per_pixel=$(astfits $inputs--hdu=$hdu --pixelscale -q \
		       | awk '{print $1*3600}')
if [ x"$matchaperturedeg" = x ]; then
   matchaperturedeg=$(echo $matchaperturedeg $arcsec_per_pixel \
                           | awk '{print $1*$2/3600}')
fi

# Check that 'segmented' is output of 'astsegment'.
if [ x"$segmented" != x ]; then
    nhdu=$(astfits $segmented --listimagehdus \
               | grep 'OBJECTS\|CLUMPS' \
               | wc -l)
    if [ $nhdu != 2 ]; then
        cat <<EOF
$scriptname: the file given to '--segmented' does not have 'CLUMPS' and
'OBJECTS' HDUs. Please give an output of 'astsegment'
EOF
        exit 1
    fi
fi







# Define a temporal directory and thefinal output file
# ----------------------------------------------------
#
# Construct the temporary directory. If the user does not specify any
# directory, then a default one with the base name of the input image will
# be constructed.  If the user set the directory, then make it. This
# directory will be deleted at the end of the script if the user does not
# want to keep it (with the `--keeptmp' option).

# The final catalog is also defined here if the user does not provide an
# explicit name. If the user has defined a specific path/name for the
# output, it will be used for saving the output file. If the user does not
# specify an output name, then a default value containing the field, min,
# and max magnitudes will will be generated.
bname_prefix=$(basename $inputs | sed 's/\.fits/ /' | awk '{print $1}')
if [ x$tmpdir = x ]; then \
  tmpdir=$(pwd)/"$bname_prefix"_psfcreateselectstar_"$field"_"$min"_"$max"
fi

if [ -d $tmpdir ]; then
  junk=1
else
  mkdir -p $tmpdir
fi

# Output
if [ x$output = x ]; then
  output="$bname_prefix"_psfcreateselectstar_"$field"_"$min"_"$max".fits
fi





# Catalog of stars
# ----------------
#
# At first check that user have catalog of stars or no. If the user geive a
# catalog to script at first with help of "--skycoverage" check the
# catalog's minimum (maximum) ra and dec are smaller (larger) than the
# image edge. If it is true with "asttable" just choose stars that have
# magnitude between 0 to maximum of magitude. If it isn't stop script. If
# user don't provide catalog with help of "--astquery" download the
# catalog.
if [ x"$catalog" != x ]; then
    # Find minimum value of image's ra.
    minraimg=$(astfits $inputs --hdu=$hdu --skycoverage \
               | grep 'RA' | awk '{print $2}')

    # Find minimum value of image's dec.
    mindecimg=$(astfits $inputs --hdu=$hdu --skycoverage \
                | grep 'DEC' | awk '{print $2}')

    # Find maximum value of image's ra.
    maxraimg=$(astfits $inputs --hdu=$hdu --skycoverage \
               | grep 'RA' | awk '{print $3}')

    # Find maximum value of image's dec.
    maxdecimg=$(astfits $inputs --hdu=$hdu --skycoverage \
                | grep 'DEC' | awk '{print $3}')

    # Find minimum value of catalog's ra.
    minracatalog=$(asttable $catalog -cRA \
                   | aststatistics --minimum)

    # Find minimum value of catalog's dec.
    mindeccatalog=$(asttable $catalog -cDEC \
                    | aststatistics --minimum)

    # Find maximum value of catalog's ra.
    maxracatalog=$(asttable $catalog -cRA \
                   | aststatistics --maximum)

    # Find maximum value of catalog's dec.
    maxdeccatalog=$(asttable $catalog -cDEC \
                    | aststatistics --maximum)

    # Check that catalog overlap the image or not.
    check=$(echo $minraimg $minracatalog $mindecimg $mindeccatalog \
                 $maxraimg $maxracatalog $maxdecimg $maxdeccatalog \
                | awk '{print ($1 >= $2 && $3 >= $4 && $5 <= $6 && $7 <= $8)}')

    # If catalog overlap the image, just select stars with magnitude
    # between 0 to maximmum range that user choose.
    if [ "$check" = 1 ]; then

        # Make a file for output of 'asttable'.
        query=$tmpdir/query.fits
        if [ -f $query ]; then
            echo "External Cataloge already exists "
        else
            # Select stars with magnitude between 0 to maximum.
            asttable $catalog --range=$field,0:$max --sort=$field \
                     --range=ra,$minraimg:$maxraimg \
                     --range=dec,$mindecimg:$maxdecimg \
                     --output=$query

            numstars=$(asttable $query -i | grep 'Number of rows' | awk '{print $4}')
            if [ "$numstars" = 0 ]; then
                rm -rf $tmpdir
                echo "There were no stars in magnitude range $min to $max"
                exit 2
            fi
        fi
    else
        # If catalog doesn't overlap the image stop.
        echo "Tha catalog is smaller than the image and don't overlap image."
        exit 1
    fi
# If user doesn't provide catalog, with use of 'astquery' catalog of stars
# with magnitude between 0 to max from gaia has been downloaded.
else
    # Make a 'query.fits' for output of 'astquery'.
    query=$tmpdir/query.fits
    if [ -f $query ]; then
        echo "External Cataloge already exists "
    else
        # Download catalog of stars with magnitude between 0 to max from
        # Gaia with '--astquery'.
        astquery $dataset --output=$query --overlapwith=$inputs \
  	         --hdu=$hdu --column=ra,dec,$field,parallax,parallax_error \
	         --range=$field,0:$max --sort=$field $quiet
    fi
fi




# Select stars with good parallax.
#---------------------------------
#
# With some options of 'asttable' such as '--noblank'
# remove all stras have parallax larger than three
# times of parallax-error.
goodparallax=$tmpdir/parallax-good.fits
asttable $query -cra,dec -c$field \
         --range=$field,$min:$max --colinfoinstdout --noblank=4 \
	 -c'arith parallax parallax abs \
                  parallax_error 3 x lt nan where ' \
	 | asttable -cra,dec -c$field --output=$goodparallax





# Find circular objects.
#-----------------------
#
# Considering only objects with an axis ratio above 1.
# To do that, first of all a catalogue of clumps is
# computed using 'astmkcatalog'. In second step, match
# catalogue of stars from Gaia data sets with clump
# catalogue. Finally apply the mimimumm axis atio
# criteria.
circular=$tmpdir/circular-objects.fits
if [ -f $circular ]; then
    echo "Catalog of circular objects already exists "
else
    if [ x"$segmented" = x ]; then
	cp $goodparallax $circular
    else
	# Intermediate files.
	qraw=$tmpdir/axisratio-raw.fits
	qmatch=$tmpdir/axisratio-match.fits

	# Measure axisratios
	astmkcatalog $segmented --ids --ra --dec --axisratio \
                     --positionangle --fwhm --clumpscat \
                     $quiet --output=$qraw

	# Match with downloaded cataloge
	astmatch $goodparallax --ccol1=ra,dec \
		 $qraw --hdu2=CLUMPS --ccol2=RA,DEC \
		 --aperture=$matchaperturedeg \
		 --output=$qmatch $quiet \
		 --outcols=ara,adec,a$field,bAXIS_RATIO,bPOSITION_ANGLE,bFWHM

	# Select circular objects
	asttable $qmatch --range=AXIS_RATIO,$minaxisratio,1 \
		 --output=$circular $quiet
    fi
fi





# Determine the number of neighbors around each object.
#------------------------------------------------------
#
# First of all based on ra and dec of circular stars determine
# the distance between the circular star and brigther stars in
# minimumm distance and based on '--noblank' and 'where' remove
# stars tha have distance larger than minimumm distance. Then
# remove each circular stars that have more than 9 neighbors.
lessneighbor=$tmpdir/less-than-9-stars.txt
moreneighbor=$tmpdir/more-than-9-stars.txt
echo "# Column 1: ra [deg,f64] Right ascension" >> $lessneighbor
echo "# Column 2: dec [deg,f64] Declination" >> $lessneighbor
echo "# Column 3: photo-g-mean-mag [mag,f64] Magnitude" >> $lessneighbor

# Find ra and dec of each circul star.
asttable $circular -cra,dec -c$field | while read r d mag; do

   # Make a file for number of neighbourhood.
   numberneighbor=$tmpdir/"$r"th-star-neighbor.fits

   # Find number of neighborhod for each star.
   asttable $query -cra,dec -c$field \
	    --colinfoinstdout \
	    -c'arith ra dec '$r' '$d' distance-on-sphere \
                     set-i i i '$mindistdeg' gt nan where' \
            --noblank=4 \
            --output=$numberneighbor

   # Check number of neighborhod and remove each star that
   # has more than 9 neighbors.
   lof=$(cat $numberneighbor | wc -l)
   if [ $lof -le 9 ]; then
       echo $r $d $mag >> $lessneighbor
   else
       echo $r $d $mag >> $moreneighbor
   fi
done





# Output of selected circular stars with good parallax and
# less than 9 neighbors in fits format.
asttable $lessneighbor --output=$output





# Run script quiet or not
#------------------------
#
# If user do not want to see all steps of run,
# the 'quiet' option must be used. Without this
# option user can see all steps of run.
if [ x"$quiet" = x ]; then
   echo "Number of downloaded stars from gaia: \
         $(asttable $query | wc -l)"
   echo "Number of stars with good parallax: \
         $(asttable $goodparallax | wc -l)"
   echo "Number of stars with less than 9 neghbors: \
         $(asttable $lessneighbor | wc -l)"
   if [ ! -$segmented ]; then
           echo "Number of stars matched with clump catalogue: \
                 $(asttable $qmatch)"
   fi
fi




# Remove temporary directory
#---------------------------
#
# If user dos not specify to keep build file
# with the option of --keeptmp', then the
# directory will be removed.
if [ x"$keeptmp" = x ]; then
   rm -rf $tmpdir
fi
