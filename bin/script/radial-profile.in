#!/bin/sh

# Obtain averaged radial profiles, run with `--help', or see description
# under `print_help' (below) for more.
#
# Original author:
#   Raul Infante-Sainz <infantesainz@gmail.com>
# Contributing author(s):
#   Mohammad Akhlaghi <mohammad@akhlaghi.org>
#   Zahra Sharbaf <zahra.sharbaf2@gmail.com>
#   Carlos Morales-Socorro <cmorsoc@gmail.com>
# Copyright (C) 2020-2021, Free Software Foundation, Inc.
#
# Gnuastro is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# Gnuastro is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along
# with Gnuastro. If not, see <http://www.gnu.org/licenses/>.


# Exit the script in the case of failure
set -e





# Default option values (can be changed with options on the command-line).
hdu=1
quiet=0
qratio=1
pangle=0
tmpdir=""
keeptmp=0
rmax="max"
mode="img"
xcenter="center"
ycenter="center"
measure="--mean"
sigmaclip="3,0.2"
output="default"
version=@VERSION@
scriptname=@SCRIPT_NAME@





# Output of `--usage' and `--help':
print_usage() {
    cat <<EOF
$scriptname: run with '--help' for list of options
EOF
}

print_help() {
    cat <<EOF
Usage: $scriptname [OPTION] FITS-files

This script is part of GNU Astronomy Utilities $version.

This script will consider the input image for constructing the radial
profile around a given center with elliptical apertures.

For more information, please run any of the following commands. In
particular the first contains a very comprehensive explanation of this
script's invocation: expected input(s), output(s), and a full description
of all the options.

     Inputs/Outputs and options:           $ info $scriptname
     Full Gnuastro manual/book:            $ info gnuastro

If you couldn't find your answer in the manual, you can get direct help from
experienced Gnuastro users and developers. For more information, please run:

     $ info help-gnuastro

$scriptname options:
 Input:
  -h, --hdu=STR           HDU/extension of all input FITS files.
  -O, --mode=STR          Coordinate mode: img or wcs.
  -x, --xcenter=FLT       Coordinate of the center along the first axis.
  -y, --ycenter=FLT       Coordinate of the center along the second axis.
  -R, --rmax=FLT          Maximum radius for the radial profile (in pixels).
  -Q, --qratio=FLT        Axis ratio for ellipse profiles (A/B).
  -p, --pangle=FLT        Position angle for ellipse profiles.
  -m, --measure="STR"     Measurement operator ("--mean", "--median", etc.).
  -s, --sigmaclip=FLT,FLT Parameters for sigma clipping measure operators.

 Output:
  -k, --keeptmp           Keep temporal/auxiliar files.
  -o, --output            Output table with the radial profile.

 Operating mode:
  -h, --help              Print this help list.
      --cite              BibTeX citation for this program.
  -q, --quiet             Don't print the list.
  -V, --version           Print program version.

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.

GNU Astronomy Utilities home page: http://www.gnu.org/software/gnuastro/

Report bugs to bug-gnuastro@gnu.org.
EOF
}





# Output of `--version':
print_version() {
    cat <<EOF
$scriptname (GNU Astronomy Utilities) $version
Copyright (C) 2020-2021, Free Software Foundation, Inc.
License GPLv3+: GNU General public license version 3 or later.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written/developed by Raul Infante-Sainz
EOF
}





# Functions to check option values and complain if necessary.
on_off_option_error() {
    if [ "x$2" = x ]; then
        echo "$scriptname: '$1' doesn't take any values."
    else
        echo "$scriptname: '$1' (or '$2') doesn't take any values."
    fi
    exit 1
}

check_v() {
    if [ x"$2" = x ]; then
        echo "$scriptname: option '$1' requires an argument."
        echo "Try '$scriptname --help' for more information."
        exit 1;
    fi
}





# Separate command-line arguments from options. Then put the option
# value into the respective variable.
#
# OPTIONS WITH A VALUE:
#
#   Each option has three lines because we want to all common formats: for
#   long option names: `--longname value' and `--longname=value'. For short
#   option names we want `-l value', `-l=value' and `-lvalue' (where `-l'
#   is the short version of the hypothetical `--longname' option).
#
#   The first case (with a space between the name and value) is two
#   command-line arguments. So, we'll need to shift it two times. The
#   latter two cases are a single command-line argument, so we just need to
#   "shift" the counter by one. IMPORTANT NOTE: the ORDER OF THE LATTER TWO
#   cases matters: `-h*' should be checked only when we are sure that its
#   not `-h=*').
#
# OPTIONS WITH NO VALUE (ON-OFF OPTIONS)
#
#   For these, we just want the two forms of `--longname' or `-l'. Nothing
#   else. So if an equal sign is given we should definitely crash and also,
#   if a value is appended to the short format it should crash. So in the
#   second test for these (`-l*') will account for both the case where we
#   have an equal sign and where we don't.
while [ $# -gt 0 ]
do
    case "$1" in
        # Input parameters.
        -h|--hdu)           hdu="$2";                                  check_v "$1" "$hdu";  shift;shift;;
        -h=*|--hdu=*)       hdu="${1#*=}";                             check_v "$1" "$hdu";  shift;;
        -h*)                hdu=$(echo "$1"  | sed -e's/-h//');        check_v "$1" "$hdu";  shift;;
        -O|--mode)          mode="$2";                                 check_v "$1" "$mode";  shift;shift;;
        -O=*|--mode=*)      mode="${1#*=}";                            check_v "$1" "$mode";  shift;;
        -O*)                mode=$(echo "$1"  | sed -e's/-O//');       check_v "$1" "$mode";  shift;;
        -x|--xcenter)       xcenter="$2";                              check_v "$1" "$xcenter";  shift;shift;;
        -x=*|--xcenter=*)   xcenter="${1#*=}";                         check_v "$1" "$xcenter";  shift;;
        -x*)                xcenter=$(echo "$1"  | sed -e's/-x//');    check_v "$1" "$xcenter";  shift;;
        -y|--ycenter)       ycenter="$2";                              check_v "$1" "$ycenter";  shift;shift;;
        -y=*|--ycenter=*)   ycenter="${1#*=}";                         check_v "$1" "$ycenter";  shift;;
        -y*)                ycenter=$(echo "$1"  | sed -e's/-y//');    check_v "$1" "$ycenter";  shift;;
        -R|--rmax)          rmax="$2";                                 check_v "$1" "$rmax";  shift;shift;;
        -R=*|--rmax=*)      rmax="${1#*=}";                            check_v "$1" "$rmax";  shift;;
        -R*)                rmax=$(echo "$1"  | sed -e's/-R//');       check_v "$1" "$rmax";  shift;;
        -Q|--qratio)        qratio="$2";                               check_v "$1" "$qratio";  shift;shift;;
        -Q=*|--qratio=*)    qratio="${1#*=}";                          check_v "$1" "$qratio";  shift;;
        -Q*)                qratio=$(echo "$1"  | sed -e's/-Q//');     check_v "$1" "$qratio";  shift;;
        -p|--pangle)        pangle="$2";                               check_v "$1" "$pangle";  shift;shift;;
        -p=*|--pangle=*)    pangle="${1#*=}";                          check_v "$1" "$pangle";  shift;;
        -p*)                pangle=$(echo "$1"  | sed -e's/-p//');     check_v "$1" "$pangle";  shift;;
        -m|--measure)       measure="$2";                              check_v "$1" "$measure";  shift;shift;;
        -m=*|--measure=*)   measure="${1#*=}";                         check_v "$1" "$measure";  shift;;
        -m*)                measure=$(echo "$1"  | sed -e's/-m//');    check_v "$1" "$measure";  shift;;
        -s|--sigmaclip)     sigmaclip="$2";                            check_v "$1" "$sigmaclip";  shift;shift;;
        -s=*|--sigmaclip=*) sigmaclip="${1#*=}";                       check_v "$1" "$sigmaclip";  shift;;
        -s*)                sigmaclip=$(echo "$1"  | sed -e's/-s//');  check_v "$1" "$sigmaclip";  shift;;


        # Output parameters
        -k|--keeptmp)     keeptmp=1; shift;;
        -k*|--keeptmp=*)  on_off_option_error --keeptmp -k;;
        -t|--tmpdir)      tmpdir="$2";                          check_v "$1" "$tmpdir";  shift;shift;;
        -t=*|--tmpdir=*)  tmpdir="${1#*=}";                     check_v "$1" "$tmpdir";  shift;;
        -t*)              tmpdir=$(echo "$1" | sed -e's/-t//'); check_v "$1" "$tmpdir";  shift;;
        -o|--output)      output="$2";                          check_v "$1" "$output"; shift;shift;;
        -o=*|--output=*)  output="${1#*=}";                     check_v "$1" "$output"; shift;;
        -o*)              output=$(echo "$1" | sed -e's/-o//'); check_v "$1" "$output"; shift;;

        # Non-operating options.
        -q|--quiet)       quiet=1; shift;;
        -q*|--quiet=*)    on_off_option_error --quiet -q;;
        -?|--help)        print_help; exit 0;;
        -'?'*|--help=*)   on_off_option_error --help -?;;
        -V|--version)     print_version; exit 0;;
        -V*|--version=*)  on_off_option_error --version -V;;
        --cite)           astfits --cite; exit 0;;
        --cite=*)         on_off_option_error --cite;;

        # Unrecognized option:
        -*) echo "$scriptname: unknown option '$1'"; exit 1;;

        # Not an option (not starting with a `-'): assumed to be input FITS
        # file name.
        *) inputs="$1 $inputs"; shift;;
    esac
done





# Basic sanity checks on arguments.
if [ x"$inputs" = x ]; then
    echo "$scriptname: no input FITS files."
    echo "Run with '--help' for more information on how to run."
    exit 1
fi




# If one of X or Y are given the other also needs to be given.
if [ "z$xcenter" = zcenter ]; then
  if ! [ "z$ycenter" = zcenter ]; then
    echo "Center position's Y axis value is given, but not X!"
    exit 1
  fi
else
  if [ "z$ycenter" = zcenter ]; then
    echo "Center position's X axis value is given, but not Y!"
    exit 1
  fi
fi





# Convert center to image coordinates if necessary
# ------------------------------------------------
#
# If the user provides specific coordinates in WCS (--mode=wcs), then convert
# them to image mode so we can safely assume image coordianates from now on. To
# do that, WCS information from the input header image is used.
if ! [ "z$xcenter" = zcenter ]; then
  if [ $mode = wcs ]; then
    xy=$(echo "$xcenter $ycenter" \
             | asttable -c'arith $1 $2 wcstoimg' \
                        --wcsfile=$inputs --wcshdu=$hdu)
    xcenter=$(echo $xy | awk '{print $1}');
    ycenter=$(echo $xy | awk '{print $2}');
  fi
fi





# Set default central position
# ----------------------------
#
# If the user does not set the x and y coordinates to be `center' (the
# coordinates of the object), then compute the center of the image for
# constructing the profiles. Here, we are assuming that the object is already
# centered on the input image.
#
# In the FITS standard, pixels are counted from 1, and the integers are in
# the center of the pixel. So after dividing the pixel size of the image by
# 2, we should add it with 0.5 to be the `center' of the image.
if [ "z$xcenter" = zcenter ]; then
  xcenter=$(astfits $inputs --hdu=$hdu | awk '/^NAXIS1/{print $3/2+0.5}')
  ycenter=$(astfits $inputs --hdu=$hdu | awk '/^NAXIS2/{print $3/2+0.5}')
fi





# Calculate the maximum radius
# ----------------------------
#
# If the user set the --rmax parameter to `max', then compute the maximum
# radius possible on the image.
#
# If the user has not given any maximum radius, we give the most reliable
# maximum radius (where the full circumference will be within the
# image). If the radius goes outside the image, then the measurements and
# calculations can be biased, so when the user has not provided any maximum
# radius, we should only confine ourselves to a radius where the results
# are reliable.
#
#             Y--------------
#              |            |       The maximum radius (to ensure the profile
#            y |........*   |       lies within the image) is the smallest
#              |        .   |       one of these values:
#              |        .   |              x, y, X-x, Y-y
#              --------------
#              0        x   X
#
if [ "z$rmax" = zmax ]; then
  rmax=$(astfits $inputs --hdu=$hdu \
             | awk '/^NAXIS1/{X=$3} /^NAXIS2/{Y=$3} \
                    END{ x='$xcenter'; y='$ycenter'; \
                         printf("%s\n%s\n%s\n%s", x, y, X-x, Y-y); }' \
             | aststatistics --minimum )
fi





# Define the final output file and temporal directory
# ---------------------------------------------------
#
# Here, it is defined the final output file containing the radial profile.
# If the user has defined a specific path/name for the output, it will be
# used for saving the output file. If the user does not specify a output name,
# then a default value containing the center and mode will be generated.
bname_prefix=$(basename $inputs | sed 's/\.fits/ /' | awk '{print $1}')
defaultname=$(pwd)/"$bname_prefix"_rprofile_$mode"_$xcenter"_"$ycenter"
if [ z$output = zdefault ]; then output="$defaultname.fits"; fi

# Construct the temporal directory. If the user does not specify any directory,
# then a default one with the base name of the input image will be constructed.
# If the user set the directory, then make it. This directory will be deleted
# at the end of the script if the user does not want to keep it (with the
# `--keeptmp' option).
if [ z$tmpdir = z        ]; then tmpdir=$defaultname; fi
mkdir -p $tmpdir





# Crop image
# ----------
#
# Crop the input image around the desired point so we can continue processing
# only on those pixels (we do not need the other pixels).
#
# The crop's output always has the range of pixels from the original image used
# in the `ICF1PIX' keyword value. So, to find the new center (important if it
# is sub-pixel precission), we can simply get the first and third value of that
# string, and convert to the cropped coordinate system. Note that because FITS
# pixel couting starts from 1, we need to subtract `1'.
crop=$tmpdir/crop.fits
cropwidth=$(echo $rmax | awk '{print $1*2+1}')
astcrop $inputs --hdu=$hdu --center=$xcenter,$ycenter --mode=img \
        --width=$cropwidth --output=$crop
dxy=$(astfits $crop -h1 \
          | grep ICF1PIX \
          | sed -e"s/'/ /g" -e's/\:/ /g' -e's/,/ /' \
          | awk '{print $3-1, $5-1}')
xcenter=$(echo "$xcenter $cropwidth $dxy" | awk '{if($1>int($2/2)) print $1-$3; else print int($2/2)+$1-int($1)}')
ycenter=$(echo "$ycenter $cropwidth $dxy" | awk '{if($1>int($2/2)) print $1-$4; else print int($2/2)+$1-int($1)}')





# Generate the apertures image
# ----------------------------
#
# The apertures image is generated using MakeProfiles with the parameters
# specified in the echo statement:

# rmax    -- maximum radius value (in pixels)
# xcenter -- X center position (in pixels).
# ycenter -- Y center position (in pixels).
# 7       -- type of the profiles (radial distance).
# 1       -- the Sersic or Moffat index.
# pangle  -- position angle.
# qratio  -- axis ratio.
# rmax    -- magnitude of the profile within the truncation radius (rmax).
# 1       -- Truncation in radius unit.
apertures=$tmpdir/apertures.fits
echo "$rmax $xcenter $ycenter 7 $rmax 1 $pangle $qratio $rmax 1" \
     | astmkprof --background=$crop --backhdu=1 --mforflatpix \
                 --mode=img --clearcanvas --type=int16 \
                 --circumwidth=1 --replace --output=$apertures





# Obtain the radial profile
# -------------------------
#
# The radial profile is obtained using Catalog. In practice, what is done is to
# obtain a catalogue using the segmentation image previously generated (the
# elliptical apertures) and the original input image for measuring the values.
astmkcatalog $apertures -h1 --valuesfile=$crop --valueshdu=1 \
             --ids $measure --sigmaclip=$sigmaclip --output=$output





# Remove temporal files
# ---------------------
#
# If the user does not specify to keep the temporal files with the option
# `--keeptmp', then remove the whole directory.
if [ $keeptmp = 0 ]; then
    rm -rf $tmpdir
fi
