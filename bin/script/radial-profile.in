#!/bin/sh

# Obtain averaged radial profiles, run with `--help', or see description
# under `print_help' (below) for more.
#
# Original author:
#   Copyright (C) 2020   Raul Infante-Sainz <infantesainz@gmail.com>
# Contributing author(s):
#   Copyright (C) 2020   Mohammad Akhlaghi <mohammad@akhlaghi.org>
#   Copyright (C) 2020   Zahra Sharbaf <zahra.sharbaf2@gmail.com>
# Copyright (C) 2020, Free Software Foundation, Inc.
#
# Gnuastro is free software: you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free
# Software Foundation, either version 3 of the License, or (at your option)
# any later version.
#
# Gnuastro is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
# more details.
#
# You should have received a copy of the GNU General Public License along
# with Gnuastro. If not, see <http://www.gnu.org/licenses/>.


# Exit the script in the case of failure
set -e





# Default option values (can be changed with options on the command-line).
hdu=1
rmax=max
mode=img
x=center
y=center
m=median
s='3,0.2'
Q=1
p=0
b=1
w=1
k=1
X="1 x"
Y="1 x"
Z="1 x"
i="radius"
j="v"
l="S/N"
quiet=0
prefix=./
tmpdir=""
output="default"
version=@VERSION@
scriptname=@SCRIPT_NAME@





# Output of `--usage' and `--help':
print_usage() {
    cat <<EOF
$scriptname: run with '--help' for list of options
EOF
}

print_help() {
    cat <<EOF
Usage: $scriptname [OPTION] FITS-files

This script is part of GNU Astronomy Utilities $version.

This script will consider the input image for constructing the radial
profile around a given center with elliptical apertures.

For more information, please run any of the following commands. In
particular the first contains a very comprehensive explanation of this
script's invocation: expected input(s), output(s), and a full description
of all the options.

     Inputs/Outputs and options:           $ info $scriptname
     Full Gnuastro manual/book:            $ info gnuastro

If you couldn't find your answer in the manual, you can get direct help from
experienced Gnuastro users and developers. For more information, please run:

     $ info help-gnuastro

$scriptname options:
 Input:
  -h, --hdu=STR           HDU/extension of all input FITS files.
  -O, --mode=STR          Coordinate mode: img or wcs.
  -x, --xcenter=FLT       Coordinate of the center along the first axis.
  -y, --ycenter=FLT       Coordinate of the center along the second axis.
  -R, --rmax=FLT          Maximum radius for the radial profile (in pixels).
  -Q, --qratio=FLT        Axis ratio for ellipse profiles (A/B).
  -p, --pangle=FLT        Position angle for ellipse profiles.
  -m, --measure=STR       Operator for measuring the value (mean, median, etc.).
  -s, --sigmaclip=FLT,FLT Parameters for sigma clipping measure operator.
  -b, --binning=INT       Size of the bin for averaging group of pixels.
  -a, --cprofiles=STR     Configuration file for astmkprof.
  -c, --ccatalog=STR      Configuration file for astmkcatalog.
  -X, --xarith=STR        Operation for the first column of radial profile.
  -Y, --yarith=STR        Operation for the second column of the radial profile.
  -i, --iname=STR         Name of first column of radial profile (radius).
  -j, --jname=STR         Name of second column of radial profile (measured value).
  -l, --lname=STR         Name of third column of radial profile (S/N).

 Output:
  -k, --keeptemp          Keep temporal/auxiliar files.
  -o, --output            Output table with the radial profile.

 Operating mode:
  -h, --help              Print this help list.
      --cite              BibTeX citation for this program.
  -q, --quiet             Don't print the list.
  -V, --version           Print program version.

Mandatory or optional arguments to long options are also mandatory or optional
for any corresponding short options.

GNU Astronomy Utilities home page: http://www.gnu.org/software/gnuastro/

Report bugs to bug-gnuastro@gnu.org.
EOF
}





# Output of `--version':
print_version() {
    cat <<EOF
$scriptname (GNU Astronomy Utilities) $version
Copyright (C) 2020, Free Software Foundation, Inc.
License GPLv3+: GNU General public license version 3 or later.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.

Written/developed by Raul Infante-Sainz
EOF
}





# Functions to check option values and complain if necessary.
on_off_option_error() {
    if [ "x$2" = x ]; then
        echo "$scriptname: '$1' doesn't take any values."
    else
        echo "$scriptname: '$1' (or '$2') doesn't take any values."
    fi
    exit 1
}

check_v() {
    if [ x"$2" = x ]; then
        echo "$scriptname: option '$1' requires an argument."
        echo "Try '$scriptname --help' for more information."
        exit 1;
    fi
}





# Separate command-line arguments from options. Then put the option
# value into the respective variable.
#
# OPTIONS WITH A VALUE:
#
#   Each option has three lines because we want to all common formats: for
#   long option names: `--longname value' and `--longname=value'. For short
#   option names we want `-l value', `-l=value' and `-lvalue' (where `-l'
#   is the short version of the hypothetical `--longname' option).
#
#   The first case (with a space between the name and value) is two
#   command-line arguments. So, we'll need to shift it two times. The
#   latter two cases are a single command-line argument, so we just need to
#   "shift" the counter by one. IMPORTANT NOTE: the ORDER OF THE LATTER TWO
#   cases matters: `-h*' should be checked only when we are sure that its
#   not `-h=*').
#
# OPTIONS WITH NO VALUE (ON-OFF OPTIONS)
#
#   For these, we just want the two forms of `--longname' or `-l'. Nothing
#   else. So if an equal sign is given we should definitely crash and also,
#   if a value is appended to the short format it should crash. So in the
#   second test for these (`-l*') will account for both the case where we
#   have an equal sign and where we don't.
while [ $# -gt 0 ]
do
    case "$1" in
        # Input parameters.
        -h|--hdu)         hdu="$2";                           check_v "$1" "$hdu";  shift;shift;;
        -h=*|--hdu=*)     hdu="${1#*=}";                      check_v "$1" "$hdu";  shift;;
        -h*)              hdu=$(echo "$1"  | sed -e's/-h//'); check_v "$1" "$hdu";  shift;;
        -O|--mode)        mode="$2";                           check_v "$1" "$mode";  shift;shift;;
        -O=*|--mode=*)    mode="${1#*=}";                      check_v "$1" "$mode";  shift;;
        -O*)              mode=$(echo "$1"  | sed -e's/-O//'); check_v "$1" "$mode";  shift;;
        -x|--xcenter)     x="$2";                           check_v "$1" "$x";  shift;shift;;
        -x=*|--xcenter=*) x="${1#*=}";                      check_v "$1" "$x";  shift;;
        -x*)              x=$(echo "$1"  | sed -e's/-x//'); check_v "$1" "$x";  shift;;
        -y|--ycenter)     y="$2";                           check_v "$1" "$y";  shift;shift;;
        -y=*|--ycenter=*) y="${1#*=}";                      check_v "$1" "$y";  shift;;
        -y*)              y=$(echo "$1"  | sed -e's/-y//'); check_v "$1" "$y";  shift;;
        -R|--rmax)        rmax="$2";                           check_v "$1" "$rmax";  shift;shift;;
        -R=*|--rmax=*)    rmax="${1#*=}";                      check_v "$1" "$rmax";  shift;;
        -R*)              rmax=$(echo "$1"  | sed -e's/-R//'); check_v "$1" "$rmax";  shift;;
        -Q|--qratio)      Q="$2";                           check_v "$1" "$Q";  shift;shift;;
        -Q=*|--qratio=*)  Q="${1#*=}";                      check_v "$1" "$Q";  shift;;
        -Q*)              Q=$(echo "$1"  | sed -e's/-q//'); check_v "$1" "$Q";  shift;;
        -p|--pangle)      p="$2";                           check_v "$1" "$p";  shift;shift;;
        -p=*|--pangle=*)  p="${1#*=}";                      check_v "$1" "$p";  shift;;
        -p*)              p=$(echo "$1"  | sed -e's/-p//'); check_v "$1" "$p";  shift;;
        -m|--measure)     m="$2";                           check_v "$1" "$m";  shift;shift;;
        -m=*|--measure=*) m="${1#*=}";                      check_v "$1" "$m";  shift;;
        -m*)              m=$(echo "$1"  | sed -e's/-m//'); check_v "$1" "$m";  shift;;
        -s|--sigmaclip)      s="$2";                           check_v "$1" "$s";  shift;shift;;
        -s=*|--sigmaclip=*)  s="${1#*=}";                      check_v "$1" "$s";  shift;;
        -s*)                 s=$(echo "$1"  | sed -e's/-s//'); check_v "$1" "$s";  shift;;
        -b|--binning)     b="$2";                           check_v "$1" "$b";  shift;shift;;
        -b=*|--binning=*) b="${1#*=}";                      check_v "$1" "$b";  shift;;
        -b*)              b=$(echo "$1"  | sed -e's/-b//'); check_v "$1" "$b";  shift;;
        -a|--caper)       a="$2";                           check_v "$1" "$a";  shift;shift;;
        -a=*|--caper=*)   a="${1#*=}";                      check_v "$1" "$a";  shift;;
        -a*)              a=$(echo "$1"  | sed -e's/-a//'); check_v "$1" "$a";  shift;;
        -c|--ccat)        c="$2";                           check_v "$1" "$c";  shift;shift;;
        -c=*|--ccat=*)    c="${1#*=}";                      check_v "$1" "$c";  shift;;
        -c*)              c=$(echo "$1"  | sed -e's/-c//'); check_v "$1" "$c";  shift;;
        -X|--xarith)     X="$2";                            check_v "$1" "$X";  shift;shift;;
        -X=*|--xarith=*) X="${1#*=}";                       check_v "$1" "$X";  shift;;
        -X*)             X=$(echo "$1"  | sed -e's/-X//');  check_v "$1" "$X";  shift;;
        -Y|--yarith)     Y="$2";                            check_v "$1" "$Y";  shift;shift;;
        -Y=*|--yarith=*) Y="${1#*=}";                       check_v "$1" "$Y";  shift;;
        -Y*)             Y=$(echo "$1"  | sed -e's/-Y//');  check_v "$1" "$Y";  shift;;
        -Z|--zarith)     Z="$2";                            check_v "$1" "$Z";  shift;shift;;
        -Z=*|--zarith=*) Z="${1#*=}";                       check_v "$1" "$Z";  shift;;
        -Z*)             Z=$(echo "$1"  | sed -e's/-Z//');  check_v "$1" "$Z";  shift;;
        -i|--iname)      i="$2";                            check_v "$1" "$i";  shift;shift;;
        -i=*|--iname=*)  i="${1#*=}";                       check_v "$1" "$i";  shift;;
        -i*)             i=$(echo "$1"  | sed -e's/-i//');  check_v "$1" "$i";  shift;;
        -j|--jname)      j="$2";                            check_v "$1" "$j";  shift;shift;;
        -j=*|--jname=*)  j="${1#*=}";                       check_v "$1" "$j";  shift;;
        -j*)             j=$(echo "$1"  | sed -e's/-j//');  check_v "$1" "$j";  shift;;
        -l|--lname)      l="$2";                            check_v "$1" "$k";  shift;shift;;
        -l=*|--lname=*)  l="${1#*=}";                       check_v "$1" "$k";  shift;;
        -l*)             l=$(echo "$1"  | sed -e's/-l//');  check_v "$1" "$k";  shift;;


        # Output parameters
        -k|--keeptemp)    k=0; shift;;
        -k*|--keeptemp=*) on_off_option_error --keeptemp -k;;
        --tmpdir)         tmpdir="$2";                          check_v "$1" "$tmpdir"; shift;shift;;
        --tmpdir=*)       tmpdir="${1#*=}";                     check_v "$1" "$tmpdir"; shift;;
        -o|--output)      output="$2";                          check_v "$1" "$output"; shift;shift;;
        -o=*|--output=*)  output="${1#*=}";                     check_v "$1" "$output"; shift;;
        -o*)              output=$(echo "$1" | sed -e's/-o//'); check_v "$1" "$output"; shift;;

        # Non-operating options.
        -q|--quiet)       quiet=1; shift;;
        -q*|--quiet=*)    on_off_option_error --quiet -q;;
        -?|--help)        print_help; exit 0;;
        -'?'*|--help=*)   on_off_option_error --help -?;;
        -V|--version)     print_version; exit 0;;
        -V*|--version=*)  on_off_option_error --version -V;;
        --cite)           astfits --cite; exit 0;;
        --cite=*)         on_off_option_error --cite;;

        # Unrecognized option:
        -*) echo "$scriptname: unknown option '$1'"; exit 1;;

        # Not an option (not starting with a `-'): assumed to be input FITS
        # file name.
        *) inputs="$1 $inputs"; shift;;
    esac
done





# Basic sanity checks on arguments.
if [ x"$inputs" = x ]; then
    echo "$scriptname: no input FITS files."
    echo "Run with '--help' for more information on how to run."
    exit 1
fi




# If one of X or Y are given the other also needs to be given.
if [ "z$x" = zcenter ]; then
  if ! [ "z$y" = zcenter ]; then
    echo "Center position's Y axis value is given, but not X!"
    exit 1
  fi
else
  if [ "z$y" = zcenter ]; then
    echo "Center position's X axis value is given, but not Y!"
    exit 1
  fi
fi





# Convert center to image coordinates if necessary
# ------------------------------------------------
#
# If the user gave the central position, and has said its in WCS, then
# convert them to image mode so we can safely assume image coordianates
# from now on.
if ! [ "z$x" = zcenter ]; then
  if [ $mode = wcs ]; then
    xy=$(echo "$x $y" \
             | asttable -c'arith $1 $2 wcstoimg' \
                        --wcsfile=$inputs --wcshdu=$hdu)
    x=$(echo $xy | awk '{print $1}');
    y=$(echo $xy | awk '{print $2}');
  fi
fi






# Set default central position
# ----------------------------
#
# If the user don't set the x and y coordinates to be "center" (The
# coordinates of the object), then compute the center of the image for
# constructing the profiles.
#
# In the FITS standard, pixels are counted from 1, and the integers are in
# the center of the pixel. So after dividing the pixel size of the image by
# 2, we should add it with 0.5 to be the "center" of the image.
if [ "z$x" = zcenter ]; then
  x=$(astfits $inputs --hdu=$hdu | awk '/^NAXIS1/{print $3/2+0.5}')
  y=$(astfits $inputs --hdu=$hdu | awk '/^NAXIS2/{print $3/2+0.5}')
fi






# Calculate the maximum radius
# ----------------------------
#
# If the user set the rmax parameter to "max", then compute the maximum
# radius possible on the image.
#
# If the user hasn't given any maximum radius, we give the most reliable
# maximum radius (where the full circumference will be within the
# image). If the radius goes outside the image, then the measurements and
# calculations can be biased, so when the user hasn't provided any maximum
# radius, we should only confine ourselves to a radius where the results
# are reliable.
#
#             Y--------------
#              |            |       The maximum radius (to ensure the profile
#            y |........*   |       lies within the image) is the smallest
#              |        .   |       one of these values:
#              |        .   |              x, y, X-x, Y-y
#              --------------
#              0        x   X
#
if [ "z$rmax" = zmax ]; then
  rmax=$(astfits $inputs --hdu=$hdu \
             | awk '/^NAXIS1/{X=$3} /^NAXIS2/{Y=$3} \
                    END{ x='$x'; y='$y'; \
                         printf("%s\n%s\n%s\n%s", x, y, X-x, Y-y); }' \
             | aststatistics --minimum )
fi





# Define the final output file
# ----------------------------
#
# Here, it is defined the final output file containing the radial profile.
# If the user has defined a specific path/name for the output, it will be
# used for saving the output file. If the user do not specify a output name,
# then a default value containing the center and mode will be generated.
bname_prefix=$(basename $inputs | sed 's/\.fits/ /' | awk '{print $1}')
defaultname=$(pwd)/"$bname_prefix"_radial_profile_$mode"_$x"_"$y"
if [ z$tmpdir = z        ]; then tmpdir=$defaultname
else                             tmpdir=$(realpath $tmpdir); fi
if ! [ -d $tmpdir ]; then mkdir $tmpdir; fi
if [ z$output = zdefault ]; then output="$defaultname.fits"; fi





# Crop image
# ----------
#
# Crop the input image around the desired point so we can continue
# processing only on those pixels (we don't need the other pixels).
#
# Crop's output always has the range of pixels from the original image used
# in the 'ICF1PIX' keyword value. So to find the new center (important if
# it has sub-pixel positions), we can simply get the first and third value
# of that string, and convert to the cropped coordinate system. Note that
# because FITS pixel couting starts from 1, we need to subtract '1'.
crop=$tmpdir/crop.fits
cropwidth=$(echo $rmax | awk '{print $1*2+1}')
astcrop $inputs --hdu=$hdu --center=$x,$y --mode=img \
        --width=$cropwidth --output=$crop
dxy=$(astfits $crop -h1 \
          | grep ICF1PIX \
          | sed -e"s/'/ /g" -e's/\:/ /g' -e's/,/ /' \
          | awk '{print $3-1, $5-1}')
echo "x:$x"
echo "y:$y"
echo "cropwidth: $cropwidth"
echo "dxy: $dxy"
x=$(echo "$x $cropwidth $dxy" | awk '{if($1>int($2/2)) print $1-$3; else print int($2/2)+$1-int($1)}')
y=$(echo "$y $cropwidth $dxy" | awk '{if($1>int($2/2)) print $1-$4; else print int($2/2)+$1-int($1)}')





# Generate the apertures image
# ----------------------------
#
# The apertures image is genrated using MakeProfiles with the parameters
# previously specified in the ascii file.
apertures=$tmpdir/apertures.fits
echo "x:$x"
echo "y:$y"
echo "$rmax $x $y 7 $rmax 1 $p $Q $rmax 1" \
    | astmkprof --background=$crop --backhdu=1 --mforflatpix \
                --mode=$mode --clearcanvas --type=int16 \
                --circumwidth=$w --replace --output=$apertures \
                --config=$a




# Obtain the radial profile
# -------------------------
#
# The radial profile is obtained using Catalog. In practice, what is done is
# to obtain a catalogue using the segmentation image previously generated
# (the elliptical apertures) and the original input image for computing the
# values.
if [ $b = 1 ]; then
    fprofile=$tmpdir/catalog-apertures.fits
    astmkcatalog $apertures -h1 --valuesfile=$crop --valueshdu=1 \
                 --ids --$m --config=$c -o$fprofile
else
    # Detection signal
    #
    # If the user set the default value of binning variable($b) except 1,
    # we need to have signal to noise ratio column to obtain radial
    # profile.  To obtain signal to noise ratio for each radial profile; at
    # first we have to detect signal of noise.
    detection=$(echo $output | sed -e"s|.fits|_detected.fits|g")
    astnoisechisel $crop -o$detection





    # Obtain the radial profile
    # -------------------------
    #
    # The radial profile is obtained using Catalog. In practice, what is
    # done is to obtain a catalogue using the segmentation image previously
    # generated (the elliptical apertures) and the original input image for
    # computing the values. Also using of SKY_STD extinction of noisechisel
    # output for computing signal to noise ratio.
    fprofile=$tmpdir/catalog-apertures.fits
    astmkcatalog $apertures -h1 --valuesfile=$crop --valueshdu=$hdu \
                 --instd=$detection --stdhdu=SKY_STD --ids --$m --sn \
                 --config=$c -o$fprofile
fi





# Binning data
# ------------
#
# In order to increase the signal-to-noise ratio of the radial profile, it
# is possible to bin the data. It is done in any case, if the user set the
# default value of binning variable($b) except 1, because the binning will
# be equal to 1 so the output binned will be the same as the input. To do
# the binning of the data, a small Awk script is used.Because of the
# behavior of signal to noise ratio isn't linear. We used the different
# way to do binning the S/N column. Since the Awk script will print the
# columns as float values, it is necessary to change the headers. To do
# that, Sed is used to replace all ocurrences of i32 to f32.
bprofile=$tmpdir/catalog-apertures-binned.fits
if [ $b != 1 ]; then

  asttable $fprofile \
           | awk -v b=$b '/^#/{print} BEGIN { N = b }                                                                                                                              { for (i = 1; i <= 2; i++) sum[i] += $i}
                                 { for (i = 3; i == 3; i++) sum[i] += $i ** 2}
                                 {if (i != 3)
                                      {
                                        N = b
                                      }
                                  else
                                     {
                                       N = b ** 0.5
                                     }
                                 }
           NR % N == 0 { for (i = 1; i <= NF; i++)
                          {
                            printf("%.6f%s",sum[i]/N, ( i == NF) ? "\n" : " ")
                            sum[i] = 0
                          }
                        }' | asttable -o$bprofile
else
  cp $fprofile $bprofile
fi





# Modify the radial profile
# -------------------------
#
# The user may want to operate the different columns of the radial profile
# to obtain them in different units. For example, it is common to use radial
# distances in arcec or arcmin in astronomical images. If this is the case,
# the user will specify the operation to transform the radius in pixels to
# arcsecs with the --X option. The same happen with the measured column
# (--Y). They are strings that will be used in the Table program for operate
# appropiately the different columns. But before this, the necessary
# metadata information is saved in a temporal file.

# The metadata consists in the column names and comment about the
# modification by the operation. First column is the radius in pixels, the
# name of this column is set by the parameter --i (set to radius by
# default). Second column is the measured values, the name of this column
# is set by the parameter --j (set to v by default). Third column is the
# S/N values, the name of this column is set by the parameter --l (set to
# S/N by default). If the user does not give a name for the second column,
# the output name will be the combination of the default and the operator
# used for measuring in the apertures. For example, if the user choose the
# mean to make the measure (--measure or -m) and do not specify any name
# for the output column (--jname or -j), the output column name will be:
# vmean. The reason of adding the character v to the operator is because it
# may happen that in later step, the user will use the column value with
# the Table program. If this is the case, the program will crash because it
# will mix the name of the operator with the name of the column.
#
# Column names
xcolname=$i
ycolname=$j
zcolname=$l
if [ z$j = zv ]; then
  ycolname=$j$m
fi

aprofile=$tmpdir/catalog-arith.txt
echo "# Column 1: $xcolname [modified,f32,] Binned $b and arith $X" > $aprofile
echo "# Column 2: $ycolname [modified,f32,] Binned $b and arith $Y" >> $aprofile
#
if [ $b != 1 ]; then
    echo "# Column 3: $zcolname [modified,f32,] Binned $b and arith $Z" >> $aprofile

    # Make the appropiate operation over the two columns of the radial profile
    # and add it to the temporal file with the meta-data.
    asttable $bprofile \
             -c'arith $1 '"$X" \
             -c'arith $2 '"$Y" \
             -c'arith $3 '"$Z" >> $aprofile
else
    # Make the appropiate operation over the two columns of the radial profile
    # and add it to the temporal file with the meta-data.
    asttable $bprofile \
             -c'arith $1 '"$X" \
             -c'arith $2 '"$Y" >> $aprofile
fi





# Finally, read the temporal file with the metadata information as well as
# the radial profile values, and save it as a fits table using Table.
cat $aprofile | asttable -o$output





# Calculate the Half-Light Radii
# ------------------------------
#
# This parameter can calulate for that time the user set the default value
# of binning variable($b) except 1.
#
# The half-light or 'effective' radius as the radius within which half of
# the object's luminosity is contained.
if [ $b != 1 ]; then
    halfoflight=$(asttable $output | awk 'NR>=3{if(max<$2){max=$2}}END{print max/2}')
    radius=$(asttable $output \
                 | awk '{if('$(echo $halfoflight)'<=$2){line=$1;light=$2}}END{print line}')
    echo "Half-Light-Radii: $radius pixels from the center of the object"
fi








# Remove temporal files
# ---------------------
#
# If the user has specified this option, temporal files will be removed.
k=0
if [ $k = 1 ]; then
    rm $crop \
       $aprofile \
       $bprofile \
       $fprofile \
       $detection \
       $apertures
    rm -df $tmpdir
fi
